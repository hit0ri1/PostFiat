// Configuration
const ALCHEMY_API_URL = "https://eth-mainnet.g.alchemy.com/v2/Itp9SwhpZidPsDiibof5Si48oXNs2Id-"; // Replace with your key
const LIFI_USDC_ADDRESSES = {
  8453: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", // Base
  10: "0x7F5c764cBc14f9669B88837ca1490cCa17c31607", // Optimism
  59144: "0x176211869cA2b568f2A7D4EE941E073a821EE1ff", // Linea
  80094: "0x549943e04f40284185054145c6E4e9568C1D3241", // Berachain
  5000: "0x09Bc4E0D864854c6aFB6eB9A9cdF58aC190D0dF9", // Mantle
  167000: "0x07d83526730c7438048D55A4fc0b850e2aaB6f0b", // Taiko
};

const ORBITER_USDC_ADDRESSES = {
  8453: "0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA", // Base (Orbiter-specific)
  10: "0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA", // Optimism (Orbiter-specific)
  59144: "0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA", // Linea (Orbiter-specific)
  167000: "0x07d83526730c7438048D55A4fc0b850e2aaB6f0b", // Taiko
};

const FROM_ADDRESS = "0x7075f3b9C1c9fB099D000Ebb7676B1A972c2348E";
const TO_ADDRESS = "0x7075f3b9C1c9fB099D000Ebb7676B1A972c2348E";

// Different bridging amounts to test (10, 100, 1000 USDC)
const BRIDGING_AMOUNTS = [1, 10, 100, 1000];

const HEADERS = {
  "User-Agent": "Mozilla/5.0",
  "Accept": "application/json",
};

// Modify the getLiFiQuote function to accept any amount
function getLiFiQuote(fromChainId, toChainId, amount) {
  if (fromChainId == null || toChainId == null || amount == null) {
    Logger.log(`‚ùå ERROR: Undefined or null chainId or amount passed to Li.Fi`);
    return { fee: 0, time: 0, bridgeName: '', slippageUSD: 0, fromAmount: 0, toAmount: 0 };
  }

  const url = `https://li.quest/v1/quote?fromChain=${fromChainId}&toChain=${toChainId}&fromToken=USDC&toToken=USDC&fromAmount=${amount}&fromAddress=${FROM_ADDRESS}&toAddress=${TO_ADDRESS}`;

  try {
    const response = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
    const statusCode = response.getResponseCode();

    if (statusCode === 404) {
      Logger.log(`‚ùå Route Unavailable: No quotes available for route from ${getChainName(fromChainId)} to ${getChainName(toChainId)}`);
      return { fee: 0, time: 0, bridgeName: 'Route Unavailable', slippageUSD: 0, fromAmount: 0, toAmount: 0 };
    }

    const data = JSON.parse(response.getContentText());

    // Log the full API response to inspect the structure
    //Logger.log(`üìÑ API Response for ${amount}: ${JSON.stringify(data, null, 2)}`);

    if (!data.estimate) {
      Logger.log(`‚ùå No quote available for route from ${getChainName(fromChainId)} to ${getChainName(toChainId)}`);
      return { fee: 0, time: 0, bridgeName: 'Route Unavailable', slippageUSD: 0, fromAmount: 0, toAmount: 0 };
    }

    const fromAmount = parseFloat(data.estimate.fromAmount) || 0;
    const toAmount = parseFloat(data.estimate.toAmount) || 0;
    const slippage = fromAmount !== 0 ? (fromAmount - toAmount) / fromAmount : 0;
    const slippageUSD = slippage * fromAmount;

    const feeCosts = data.estimate.feeCosts || [];
    let totalFeeUSD = 0;
    if (feeCosts.length > 0) {
      totalFeeUSD = feeCosts.reduce((sum, fee) => sum + parseFloat(fee.amountUSD || 0), 0);
    }

    const gasCosts = data.estimate.gasCosts || [];
    let totalGasUSD = 0;
    if (gasCosts.length > 0) {
      totalGasUSD = gasCosts.reduce((sum, gas) => sum + parseFloat(gas.amountUSD || 0), 0);
    }

    const finalFeeUSD = totalFeeUSD > 0 ? totalFeeUSD + totalGasUSD : totalGasUSD;

    //Logger.log(`üìà Final Fee (USD) for amount ${amount}: ${finalFeeUSD}`);

    return {
      fee: finalFeeUSD,
      time: parseInt(data.estimate.executionDuration) || 0,
      bridgeName: data.toolDetails.name || 'Unknown',
      slippageUSD: slippageUSD,
      fromAmount: fromAmount,
      toAmount: toAmount
    };
  } catch (e) {
    Logger.log(`‚ùå Li.Fi Error: ${e}`);
    return { fee: 0, time: 0, bridgeName: 'Error', slippageUSD: 0, fromAmount: 0, toAmount: 0 };
  }
}

function getOrbiterQuote(fromChainId, toChainId, amount) {
  const url = `https://api.orbiter.finance/sdk/routers/simulation/receiveAmount?line=${fromChainId}%2F${toChainId}-USDC%2FUSDC&value=${amount*1000000}&endpoint=`;
  //Logger.log(url);

  try {
    const response = UrlFetchApp.fetch(url, { method: 'get', muteHttpExceptions: true });
    const data = JSON.parse(response.getContentText());
    
    if (!data.result) {
      Logger.log(`‚ùå Error: No 'result' found in API response.`);
      return { fee: 0, time: 0, slippageUSD: 0, freceivedAmount: 0 };
    }

    const fee = ((Number(data.result.tradeFeeAmount) + Number(data.result.withholdingFeeAmount) + Number(data.result.router.swapFee)).toFixed(3));
    //Logger.log('Fee ' + fee);
    const time = data.result.router.spentTime || 0; // In seconds
    //Logger.log('Time ' + time);
    const slippageUSD = (amount - data.result.targetAmount);
    const receivedAmount = data.result.targetAmount;
    return { fee, time, slippageUSD, receivedAmount};
  } 
  
  catch (e) {
    Logger.log(`‚ùå Error: ${e}`);
    return { fee: 0, time: 0, slippageUSD: 0, freceivedAmount: 0 };
  }
}


function updateBridgingData() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const liFIChains = [8453, 10, 59144, 80094, 5000, 167000];
  const orbiterChains = [8453, 10, 59144, 167000];
  
  // Adding headers to the spreadsheet
  sheet.clear();
  sheet.appendRow(['From Chain', 'To Chain', 'Bridging Amount (USDC)', 'Fee (USD)', 'Est. Bridge Time (s)', 'Bridge Name', 'Slippage (USD)', 'Received Amount (USDC)', 'Link']);

  
  // LiFi update block
  sheet.appendRow([`LiFi routes`]);
  for (const fromChainId of liFIChains) {
    for (const toChainId of liFIChains) {
      if (fromChainId !== toChainId) {
        Logger.log(`üîÑ Route: fromChainId=${getChainName(fromChainId)}, toChainId=${getChainName(toChainId)}`);

        const fromChainName = getChainName(fromChainId);
        const toChainName = getChainName(toChainId);

        if (fromChainName === "unknown" || toChainName === "unknown") {
          Logger.log(`‚ùå ERROR: Unknown chain detected for route from ${getChainName(fromChainId)} to ${getChainName(toChainId)}`);
          continue;
        }

        for (const amount of BRIDGING_AMOUNTS) {
          const liFiQuote = getLiFiQuote(fromChainId, toChainId, amount);
          const liFiFee = liFiQuote.fee;
          const liFiTime = liFiQuote.time;
          const liFiBridgeName = liFiQuote.bridgeName;
          const liFiSlippage = liFiQuote.slippageUSD;
          const liFiReceivedAmount = liFiQuote.toAmount;
          const liFiTimeFormatted = liFiTime.toFixed(4);

          sheet.appendRow([
            fromChainName,
            toChainName,
            amount,
            liFiFee,
            liFiTimeFormatted,
            liFiBridgeName,
            liFiSlippage,
            liFiReceivedAmount,
            `https://jumper.exchange/?fromAmount=${amount}&fromChain=${fromChainId}&fromToken=${LIFI_USDC_ADDRESSES[fromChainId]}&toChain=${toChainId}&toToken=${LIFI_USDC_ADDRESSES[toChainId]}`,
          ]);

          Logger.log(`‚úÖ Data written for route: ${fromChainName} -> ${toChainName} with amount: ${amount}`);
        }
      }
    }
  }

  // Orbiter update block
  sheet.appendRow([`Orbiter routes`]);
  for (const fromChainId of orbiterChains) {
    for (const toChainId of orbiterChains) {
      if (fromChainId !== toChainId) {
        Logger.log(`üîÑ Route: fromChainId=${getChainName(fromChainId)}, toChainId=${getChainName(toChainId)}`);

        const fromChainName = getChainName(fromChainId);
        const toChainName = getChainName(toChainId);

        if (fromChainName === "unknown" || toChainName === "unknown") {
          Logger.log(`‚ùå ERROR: Unknown chain detected for route from ${getChainName(fromChainId)} to ${getChainName(toChainId)}`);
          continue;
        }

        for (const amount of BRIDGING_AMOUNTS) {
          const orbiterQuote = getOrbiterQuote(fromChainId, toChainId, amount);
          const orbiterFee = orbiterQuote.fee;
          const orbiterTime = orbiterQuote.time;
          const orbiterSlippage = orbiterQuote.slippageUSD;
          const orbiterRecievedAmount = orbiterQuote.receivedAmount;

          sheet.appendRow([
            fromChainName,
            toChainName,
            amount,
            orbiterFee,
            orbiterTime,
            `No data`,
            orbiterSlippage,
            orbiterRecievedAmount,
            `https://orbiter.finance/en?src_chain=${fromChainId}&tgt_chain=${toChainId}&src_token=USDC`,
          ]);

          Logger.log(`‚úÖ Data written for route: ${fromChainName} -> ${toChainName} with amount: ${amount}`);
        }
      }
    }
  }



  setColumnAlignment(sheet);

  Logger.log("‚úÖ Bridging data update completed.");
}


// Helper function to map chain IDs to names
function getChainName(chainId) {
  const map = {
    8453: "base",
    10: "optimism",
    59144: "linea",
    80094: "Berachain",
    5000: "Mantle",
    167000: "Taiko",
  };

  if (!chainId) {
    Logger.log(`‚ùå ERROR: Invalid chainId (${chainId}) received in getChainName()`);
    return "unknown";
  }

  if (map[chainId]) {
    return map[chainId];
  } else {
    Logger.log(`‚ùå ERROR: No name found for chainId=${chainId}`);
    return "unknown";
  }
}

// After appending the rows to the sheet, set the alignment
function setColumnAlignment(sheet) {
  const range = sheet.getDataRange(); // Get the range of all data
  const numColumns = range.getNumColumns(); // Get the number of columns

  // Loop through each column and set alignment, except the one with links
  for (let col = 1; col <= numColumns; col++) {
    if (col !== 9 & col != 14) {  // Assuming the Jumper Link is in column 9 and Orbiter 14 (adjust if needed)
      sheet.getRange(1, col, sheet.getLastRow(), 1).setHorizontalAlignment("center");
    } else {
      sheet.getRange(1, col, sheet.getLastRow(), 1).setHorizontalAlignment("left");  // Align links to the left
    }
  }
}